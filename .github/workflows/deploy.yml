name: Deploy

on:
  push:
    branches:
      - develop  # テスト環境へデプロイ
      - main     # 本番環境へデプロイ

env:
  AWS_REGION: ap-northeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-1.amazonaws.com
  FRONTEND_IMAGE: photlas-frontend
  BACKEND_IMAGE: photlas-backend
  STAGING_INSTANCE_ID: i-075d50b85132855ba
  PRODUCTION_INSTANCE_ID: i-083e8c40050732b8f

jobs:
  # Dockerイメージをビルドしてプッシュ
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate image tag
      id: meta
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG="${BRANCH_NAME}-${SHORT_SHA}"
        echo "tags=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "Image tag: ${IMAGE_TAG}"

    - name: Set environment variables for frontend build
      id: env-vars
      run: |
        # フロントエンドとバックエンドは同一ドメインなので、相対URLを使用
        # Nginxリバースプロキシが /api/* をバックエンドにルーティング
        echo "VITE_API_URL=" >> $GITHUB_ENV

    - name: Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.tags }}
          ${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:latest
        build-args: |
          VITE_API_URL=${{ env.VITE_API_URL }}
          VITE_GOOGLE_MAPS_API_KEY=${{ secrets.VITE_GOOGLE_MAPS_API_KEY }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ steps.meta.outputs.tags }}
          ${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # テスト環境へデプロイ (develop branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://test.photlas.jp

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: 10

    - name: Install dependencies
      working-directory: ./frontend
      run: pnpm install --frozen-lockfile

    - name: Build frontend
      working-directory: ./frontend
      env:
        VITE_API_URL: ''
        VITE_GOOGLE_MAPS_API_KEY: ${{ secrets.VITE_GOOGLE_MAPS_API_KEY }}
      run: pnpm build

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy frontend to S3
      run: |
        aws s3 sync ./frontend/dist s3://photlas-frontend-test-${{ secrets.AWS_ACCOUNT_ID }} --delete

    - name: Invalidate CloudFront cache
      run: |
        aws cloudfront create-invalidation --distribution-id E33UFH77Q11V2Q --paths "/*"

    - name: Deploy to Staging EC2 via SSM
      env:
        DEPLOY_AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        DEPLOY_AWS_REGION: ${{ env.AWS_REGION }}
        DEPLOY_IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        DEPLOY_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        DEPLOY_DATABASE_USER: ${{ secrets.STAGING_DATABASE_USER }}
        DEPLOY_DATABASE_PASSWORD: ${{ secrets.STAGING_DATABASE_PASSWORD }}
        DEPLOY_JWT_SECRET: ${{ secrets.JWT_SECRET }}
        DEPLOY_AWS_S3_BUCKET: ${{ secrets.STAGING_S3_BUCKET }}
        DEPLOY_ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
      run: |
        # デプロイスクリプトを生成してbase64エンコード
        cat > /tmp/deploy_script.sh << 'SCRIPT_END'
        #!/bin/bash
        set -ex
        echo '=== Starting deployment ==='
        export HOME=/root
        export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
        export AWS_ACCOUNT_ID='__AWS_ACCOUNT_ID__'
        export AWS_REGION='__AWS_REGION__'
        export IMAGE_TAG='__IMAGE_TAG__'
        export DATABASE_URL='__DATABASE_URL__'
        export DATABASE_USER='__DATABASE_USER__'
        export DATABASE_PASSWORD='__DATABASE_PASSWORD__'
        export JWT_SECRET='__JWT_SECRET__'
        export AWS_S3_BUCKET='__AWS_S3_BUCKET__'
        export ECR_REGISTRY='__ECR_REGISTRY__'

        echo '=== Environment variables set ==='
        echo "IMAGE_TAG: $IMAGE_TAG"
        echo "AWS_REGION: $AWS_REGION"

        echo '=== Installing dependencies ==='
        which git || yum install -y git || dnf install -y git
        which docker || (dnf install -y docker && systemctl start docker && systemctl enable docker)
        if ! docker compose version &>/dev/null && ! which docker-compose &>/dev/null; then
          curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
        fi

        echo '=== Git config ==='
        git config --global --add safe.directory /home/ec2-user/photlas

        echo '=== ECR Login ==='
        aws ecr get-login-password --region ap-northeast-1 | docker login --username AWS --password-stdin $ECR_REGISTRY

        echo '=== Fetching latest code ==='
        if [ ! -d /home/ec2-user/photlas ]; then
          git clone https://github.com/Naeg111/Photlas.git /home/ec2-user/photlas
        fi
        cd /home/ec2-user/photlas
        git fetch origin develop
        git checkout origin/develop -- docker/docker-compose.staging.yml docker/nginx/staging.conf

        echo '=== Pulling images ==='
        docker-compose -f docker/docker-compose.staging.yml pull

        echo '=== Starting containers ==='
        docker-compose -f docker/docker-compose.staging.yml up -d --remove-orphans

        echo '=== Cleanup ==='
        docker image prune -f

        echo '=== Deployment completed ==='
        SCRIPT_END

        # プレースホルダーを実際の値に置換
        sed -i "s|__AWS_ACCOUNT_ID__|${DEPLOY_AWS_ACCOUNT_ID}|g" /tmp/deploy_script.sh
        sed -i "s|__AWS_REGION__|${DEPLOY_AWS_REGION}|g" /tmp/deploy_script.sh
        sed -i "s|__IMAGE_TAG__|${DEPLOY_IMAGE_TAG}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_URL__|${DEPLOY_DATABASE_URL}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_USER__|${DEPLOY_DATABASE_USER}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_PASSWORD__|${DEPLOY_DATABASE_PASSWORD}|g" /tmp/deploy_script.sh
        sed -i "s|__JWT_SECRET__|${DEPLOY_JWT_SECRET}|g" /tmp/deploy_script.sh
        sed -i "s|__AWS_S3_BUCKET__|${DEPLOY_AWS_S3_BUCKET}|g" /tmp/deploy_script.sh
        sed -i "s|__ECR_REGISTRY__|${DEPLOY_ECR_REGISTRY}|g" /tmp/deploy_script.sh

        # base64エンコード
        ENCODED_SCRIPT=$(base64 -w 0 /tmp/deploy_script.sh)

        # SSM経由でスクリプトを実行（base64デコードして実行）
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.STAGING_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "{\"commands\":[\"echo $ENCODED_SCRIPT | base64 -d | bash\"]}" \
          --timeout-seconds 300 \
          --query "Command.CommandId" \
          --output text)

        echo "Command ID: $COMMAND_ID"

        # コマンドの完了をポーリングで待機（最大5分）
        MAX_ATTEMPTS=60
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ env.STAGING_INSTANCE_ID }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "Pending")

          echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Status = $STATUS"

          if [ "$STATUS" = "Success" ]; then
            echo "Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment failed with status: $STATUS"
            # エラー詳細を取得
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.STAGING_INSTANCE_ID }}" \
              --query "[StandardOutputContent, StandardErrorContent]" \
              --output text
            exit 1
          fi

          ATTEMPT=$((ATTEMPT+1))
          sleep 5
        done

        if [ "$STATUS" != "Success" ]; then
          echo "Deployment timed out! Final status: $STATUS"
          exit 1
        fi

    - name: Health check
      run: |
        sleep 30
        curl -f https://test.photlas.jp/api/v1/health || exit 1
        echo "Staging deployment successful!"

  # 本番環境へデプロイ (main branch)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://photlas.jp

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: 10

    - name: Install dependencies
      working-directory: ./frontend
      run: pnpm install --frozen-lockfile

    - name: Build frontend
      working-directory: ./frontend
      env:
        VITE_API_URL: ''
        VITE_GOOGLE_MAPS_API_KEY: ${{ secrets.VITE_GOOGLE_MAPS_API_KEY }}
      run: pnpm build

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy frontend to S3
      run: |
        aws s3 sync ./frontend/dist s3://photlas-frontend-prod-${{ secrets.AWS_ACCOUNT_ID }} --delete

    - name: Invalidate CloudFront cache
      run: |
        aws cloudfront create-invalidation --distribution-id E3RXKAXCTDAFOI --paths "/*"

    - name: Deploy to Production EC2 via SSM
      env:
        DEPLOY_AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        DEPLOY_AWS_REGION: ${{ env.AWS_REGION }}
        DEPLOY_IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        DEPLOY_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        DEPLOY_DATABASE_USER: ${{ secrets.PRODUCTION_DATABASE_USER }}
        DEPLOY_DATABASE_PASSWORD: ${{ secrets.PRODUCTION_DATABASE_PASSWORD }}
        DEPLOY_JWT_SECRET: ${{ secrets.JWT_SECRET }}
        DEPLOY_AWS_S3_BUCKET: ${{ secrets.PRODUCTION_S3_BUCKET }}
        DEPLOY_ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
      run: |
        # デプロイスクリプトを生成してbase64エンコード
        cat > /tmp/deploy_script.sh << 'SCRIPT_END'
        #!/bin/bash
        set -ex
        echo '=== Starting production deployment ==='
        export HOME=/root
        export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
        export AWS_ACCOUNT_ID='__AWS_ACCOUNT_ID__'
        export AWS_REGION='__AWS_REGION__'
        export IMAGE_TAG='__IMAGE_TAG__'
        export DATABASE_URL='__DATABASE_URL__'
        export DATABASE_USER='__DATABASE_USER__'
        export DATABASE_PASSWORD='__DATABASE_PASSWORD__'
        export JWT_SECRET='__JWT_SECRET__'
        export AWS_S3_BUCKET='__AWS_S3_BUCKET__'
        export ECR_REGISTRY='__ECR_REGISTRY__'

        echo '=== Environment variables set ==='
        echo "IMAGE_TAG: $IMAGE_TAG"
        echo "AWS_REGION: $AWS_REGION"

        echo '=== Installing dependencies ==='
        which git || yum install -y git || dnf install -y git
        which docker || (dnf install -y docker && systemctl start docker && systemctl enable docker)
        if ! docker compose version &>/dev/null && ! which docker-compose &>/dev/null; then
          curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
        fi

        echo '=== Git config ==='
        git config --global --add safe.directory /home/ec2-user/photlas

        echo '=== ECR Login ==='
        aws ecr get-login-password --region ap-northeast-1 | docker login --username AWS --password-stdin $ECR_REGISTRY

        echo '=== Fetching latest code ==='
        if [ ! -d /home/ec2-user/photlas ]; then
          git clone https://github.com/Naeg111/Photlas.git /home/ec2-user/photlas
        fi
        cd /home/ec2-user/photlas
        git fetch origin main
        git checkout origin/main -- docker/docker-compose.prod.yml docker/nginx/prod.conf

        echo '=== Pulling images ==='
        docker-compose -f docker/docker-compose.prod.yml pull

        echo '=== Starting containers ==='
        docker-compose -f docker/docker-compose.prod.yml up -d --remove-orphans

        echo '=== Cleanup ==='
        docker image prune -f

        echo '=== Production deployment completed ==='
        SCRIPT_END

        # プレースホルダーを実際の値に置換
        sed -i "s|__AWS_ACCOUNT_ID__|${DEPLOY_AWS_ACCOUNT_ID}|g" /tmp/deploy_script.sh
        sed -i "s|__AWS_REGION__|${DEPLOY_AWS_REGION}|g" /tmp/deploy_script.sh
        sed -i "s|__IMAGE_TAG__|${DEPLOY_IMAGE_TAG}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_URL__|${DEPLOY_DATABASE_URL}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_USER__|${DEPLOY_DATABASE_USER}|g" /tmp/deploy_script.sh
        sed -i "s|__DATABASE_PASSWORD__|${DEPLOY_DATABASE_PASSWORD}|g" /tmp/deploy_script.sh
        sed -i "s|__JWT_SECRET__|${DEPLOY_JWT_SECRET}|g" /tmp/deploy_script.sh
        sed -i "s|__AWS_S3_BUCKET__|${DEPLOY_AWS_S3_BUCKET}|g" /tmp/deploy_script.sh
        sed -i "s|__ECR_REGISTRY__|${DEPLOY_ECR_REGISTRY}|g" /tmp/deploy_script.sh

        # base64エンコード
        ENCODED_SCRIPT=$(base64 -w 0 /tmp/deploy_script.sh)

        # SSM経由でスクリプトを実行（base64デコードして実行）
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.PRODUCTION_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "{\"commands\":[\"echo $ENCODED_SCRIPT | base64 -d | bash\"]}" \
          --timeout-seconds 300 \
          --query "Command.CommandId" \
          --output text)

        echo "Command ID: $COMMAND_ID"

        # コマンドの完了をポーリングで待機（最大5分）
        MAX_ATTEMPTS=60
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ env.PRODUCTION_INSTANCE_ID }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "Pending")

          echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Status = $STATUS"

          if [ "$STATUS" = "Success" ]; then
            echo "Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment failed with status: $STATUS"
            # エラー詳細を取得
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.PRODUCTION_INSTANCE_ID }}" \
              --query "[StandardOutputContent, StandardErrorContent]" \
              --output text
            exit 1
          fi

          ATTEMPT=$((ATTEMPT+1))
          sleep 5
        done

        if [ "$STATUS" != "Success" ]; then
          echo "Deployment timed out! Final status: $STATUS"
          exit 1
        fi

    - name: Health check
      run: |
        sleep 30
        curl -f https://photlas.jp/api/v1/health || exit 1
        echo "Production deployment successful!"
