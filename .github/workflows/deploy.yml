name: Deploy

on:
  push:
    branches:
      - develop  # テスト環境へデプロイ
      - main     # 本番環境へデプロイ

env:
  AWS_REGION: ap-northeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-1.amazonaws.com
  FRONTEND_IMAGE: photlas-frontend
  BACKEND_IMAGE: photlas-backend
  STAGING_INSTANCE_ID: i-075d50b85132855ba
  PRODUCTION_INSTANCE_ID: i-083e8c40050732b8f

jobs:
  # Dockerイメージをビルドしてプッシュ
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate image tag
      id: meta
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG="${BRANCH_NAME}-${SHORT_SHA}"
        echo "tags=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "Image tag: ${IMAGE_TAG}"

    - name: Set environment variables for frontend build
      id: env-vars
      run: |
        # フロントエンドとバックエンドは同一ドメインなので、相対URLを使用
        # Nginxリバースプロキシが /api/* をバックエンドにルーティング
        echo "VITE_API_URL=" >> $GITHUB_ENV

    - name: Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.tags }}
          ${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE }}:latest
        build-args: |
          VITE_API_URL=${{ env.VITE_API_URL }}
          VITE_GOOGLE_MAPS_API_KEY=${{ secrets.VITE_GOOGLE_MAPS_API_KEY }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ steps.meta.outputs.tags }}
          ${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # テスト環境へデプロイ (develop branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://test.photlas.jp

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Staging EC2 via SSM
      env:
        DEPLOY_AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        DEPLOY_AWS_REGION: ${{ env.AWS_REGION }}
        DEPLOY_IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        DEPLOY_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        DEPLOY_DATABASE_USER: ${{ secrets.STAGING_DATABASE_USER }}
        DEPLOY_DATABASE_PASSWORD: ${{ secrets.STAGING_DATABASE_PASSWORD }}
        DEPLOY_JWT_SECRET: ${{ secrets.JWT_SECRET }}
        DEPLOY_AWS_S3_BUCKET: ${{ secrets.STAGING_S3_BUCKET }}
        DEPLOY_ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
      run: |
        # デプロイスクリプトを生成してbase64エンコード
        DEPLOY_SCRIPT="#!/bin/bash
        set -ex
        echo '=== Starting deployment ==='
        export HOME=/root
        export AWS_ACCOUNT_ID='${DEPLOY_AWS_ACCOUNT_ID}'
        export AWS_REGION='${DEPLOY_AWS_REGION}'
        export IMAGE_TAG='${DEPLOY_IMAGE_TAG}'
        export DATABASE_URL='${DEPLOY_DATABASE_URL}'
        export DATABASE_USER='${DEPLOY_DATABASE_USER}'
        export DATABASE_PASSWORD='${DEPLOY_DATABASE_PASSWORD}'
        export JWT_SECRET='${DEPLOY_JWT_SECRET}'
        export AWS_S3_BUCKET='${DEPLOY_AWS_S3_BUCKET}'
        export ECR_REGISTRY='${DEPLOY_ECR_REGISTRY}'

        echo '=== Environment variables set ==='
        echo \"IMAGE_TAG: \$IMAGE_TAG\"
        echo \"AWS_REGION: \$AWS_REGION\"

        echo '=== Git config ==='
        git config --global --add safe.directory /home/ec2-user/photlas

        echo '=== ECR Login ==='
        aws ecr get-login-password --region ap-northeast-1 | docker login --username AWS --password-stdin \$ECR_REGISTRY

        echo '=== Fetching latest code ==='
        cd /home/ec2-user/photlas
        git fetch origin develop
        git checkout origin/develop -- docker/docker-compose.staging.yml docker/nginx/staging.conf

        echo '=== Pulling images ==='
        docker-compose -f docker/docker-compose.staging.yml pull

        echo '=== Starting containers ==='
        docker-compose -f docker/docker-compose.staging.yml up -d --remove-orphans

        echo '=== Cleanup ==='
        docker image prune -f

        echo '=== Deployment completed ==='"

        # base64エンコード
        ENCODED_SCRIPT=$(echo "$DEPLOY_SCRIPT" | base64 -w 0)

        # SSM経由でスクリプトを実行（base64デコードして実行）
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.STAGING_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "{\"commands\":[\"echo $ENCODED_SCRIPT | base64 -d | bash\"]}" \
          --timeout-seconds 300 \
          --query "Command.CommandId" \
          --output text)

        echo "Command ID: $COMMAND_ID"

        # コマンドの完了をポーリングで待機（最大5分）
        MAX_ATTEMPTS=60
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ env.STAGING_INSTANCE_ID }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "Pending")

          echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Status = $STATUS"

          if [ "$STATUS" = "Success" ]; then
            echo "Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment failed with status: $STATUS"
            # エラー詳細を取得
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.STAGING_INSTANCE_ID }}" \
              --query "[StandardOutputContent, StandardErrorContent]" \
              --output text
            exit 1
          fi

          ATTEMPT=$((ATTEMPT+1))
          sleep 5
        done

        if [ "$STATUS" != "Success" ]; then
          echo "Deployment timed out! Final status: $STATUS"
          exit 1
        fi

    - name: Health check
      run: |
        sleep 30
        curl -f https://test.photlas.jp/api/v1/health || exit 1
        echo "Staging deployment successful!"

  # 本番環境へデプロイ (main branch)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://photlas.jp

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy to Production EC2 via SSM
      env:
        DEPLOY_AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        DEPLOY_AWS_REGION: ${{ env.AWS_REGION }}
        DEPLOY_IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        DEPLOY_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        DEPLOY_DATABASE_USER: ${{ secrets.PRODUCTION_DATABASE_USER }}
        DEPLOY_DATABASE_PASSWORD: ${{ secrets.PRODUCTION_DATABASE_PASSWORD }}
        DEPLOY_JWT_SECRET: ${{ secrets.JWT_SECRET }}
        DEPLOY_AWS_S3_BUCKET: ${{ secrets.PRODUCTION_S3_BUCKET }}
        DEPLOY_ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
      run: |
        # デプロイスクリプトを生成してbase64エンコード
        DEPLOY_SCRIPT="#!/bin/bash
        set -ex
        echo '=== Starting production deployment ==='
        export HOME=/root
        export AWS_ACCOUNT_ID='${DEPLOY_AWS_ACCOUNT_ID}'
        export AWS_REGION='${DEPLOY_AWS_REGION}'
        export IMAGE_TAG='${DEPLOY_IMAGE_TAG}'
        export DATABASE_URL='${DEPLOY_DATABASE_URL}'
        export DATABASE_USER='${DEPLOY_DATABASE_USER}'
        export DATABASE_PASSWORD='${DEPLOY_DATABASE_PASSWORD}'
        export JWT_SECRET='${DEPLOY_JWT_SECRET}'
        export AWS_S3_BUCKET='${DEPLOY_AWS_S3_BUCKET}'
        export ECR_REGISTRY='${DEPLOY_ECR_REGISTRY}'

        echo '=== Environment variables set ==='
        echo \"IMAGE_TAG: \$IMAGE_TAG\"
        echo \"AWS_REGION: \$AWS_REGION\"

        echo '=== Git config ==='
        git config --global --add safe.directory /home/ec2-user/photlas

        echo '=== ECR Login ==='
        aws ecr get-login-password --region ap-northeast-1 | docker login --username AWS --password-stdin \$ECR_REGISTRY

        echo '=== Fetching latest code ==='
        cd /home/ec2-user/photlas
        git fetch origin main
        git checkout origin/main -- docker/docker-compose.prod.yml docker/nginx/prod.conf

        echo '=== Pulling images ==='
        docker-compose -f docker/docker-compose.prod.yml pull

        echo '=== Starting containers ==='
        docker-compose -f docker/docker-compose.prod.yml up -d --remove-orphans

        echo '=== Cleanup ==='
        docker image prune -f

        echo '=== Production deployment completed ==='"

        # base64エンコード
        ENCODED_SCRIPT=$(echo "$DEPLOY_SCRIPT" | base64 -w 0)

        # SSM経由でスクリプトを実行（base64デコードして実行）
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ env.PRODUCTION_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "{\"commands\":[\"echo $ENCODED_SCRIPT | base64 -d | bash\"]}" \
          --timeout-seconds 300 \
          --query "Command.CommandId" \
          --output text)

        echo "Command ID: $COMMAND_ID"

        # コマンドの完了をポーリングで待機（最大5分）
        MAX_ATTEMPTS=60
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ env.PRODUCTION_INSTANCE_ID }}" \
            --query "Status" \
            --output text 2>/dev/null || echo "Pending")

          echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Status = $STATUS"

          if [ "$STATUS" = "Success" ]; then
            echo "Deployment completed successfully!"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "Deployment failed with status: $STATUS"
            # エラー詳細を取得
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.PRODUCTION_INSTANCE_ID }}" \
              --query "[StandardOutputContent, StandardErrorContent]" \
              --output text
            exit 1
          fi

          ATTEMPT=$((ATTEMPT+1))
          sleep 5
        done

        if [ "$STATUS" != "Success" ]; then
          echo "Deployment timed out! Final status: $STATUS"
          exit 1
        fi

    - name: Health check
      run: |
        sleep 30
        curl -f https://photlas.jp/api/v1/health || exit 1
        echo "Production deployment successful!"
